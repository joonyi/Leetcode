"""
Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].

You need to return the number of important reverse pairs in the given array.
"""
class Solution(object):
    def reversePairs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # Brute Force TLE
        res = 0
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] > 2 * nums[j]:
                    res += 1

        return res

    def reversePairs2(self, nums):
        '''
        Count "important reverse pairs" while doing mergesort:
        When we're doing mergesort, original index of elements in left part (smaller side), i, must less than those in right part, j.
        Simply compare nums[i] and 2*nums[j] and sum them up.
        '''
        if len(nums) <= 1:
            return 0
        count = [0]

        def merge(nums):
            if len(nums) <= 1: return nums

            left, right = merge(nums[:len(nums) // 2]), merge(nums[len(nums) // 2:])
            L = R = 0

            while L < len(left) and R < len(right):
                if left[L] <= 2 * right[R]:
                    L += 1
                else:
                    count[0] += len(left) - L
                    R += 1
            return sorted(left + right)  # those partial lists induced during mergesort here are generated by sorted()

        merge(nums)
        return count[0]



# Anther solution is Fenwick Tree

nums = [1,3,2,3,1]
nums = [2,4,3,5,1]
print(Solution().reversePairs2(nums))
